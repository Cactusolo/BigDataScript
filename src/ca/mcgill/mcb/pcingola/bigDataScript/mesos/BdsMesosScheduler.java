package ca.mcgill.mcb.pcingola.bigDataScript.mesos;

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.util.ArrayList;
import java.util.List;

import org.apache.mesos.Protos.CommandInfo;
import org.apache.mesos.Protos.ExecutorID;
import org.apache.mesos.Protos.ExecutorInfo;
import org.apache.mesos.Protos.Filters;
import org.apache.mesos.Protos.FrameworkID;
import org.apache.mesos.Protos.MasterInfo;
import org.apache.mesos.Protos.Offer;
import org.apache.mesos.Protos.OfferID;
import org.apache.mesos.Protos.Resource;
import org.apache.mesos.Protos.SlaveID;
import org.apache.mesos.Protos.TaskID;
import org.apache.mesos.Protos.TaskInfo;
import org.apache.mesos.Protos.TaskState;
import org.apache.mesos.Protos.TaskStatus;
import org.apache.mesos.Protos.Value;
import org.apache.mesos.Scheduler;
import org.apache.mesos.SchedulerDriver;

import com.google.protobuf.ByteString;

/**
 * BDS scheduler for Mesos
 *
 * @author pcingola
 */
public class BdsMesosScheduler implements Scheduler {

	private final ExecutorInfo executor;
	private final int totalTasks;
	private int launchedTasks = 0;
	private int finishedTasks = 0;

	public BdsMesosScheduler(ExecutorInfo executor) {
		this(executor, 5);
	}

	public BdsMesosScheduler(ExecutorInfo executor, int totalTasks) {
		this.executor = executor;
		this.totalTasks = totalTasks;
	}

	/**
	 * Invoked when the scheduler becomes "disconnected" from the master
	 * (e.g., the master fails and another is taking over).
	 */
	@Override
	public void disconnected(SchedulerDriver driver) {
	}

	/**
	 * Invoked when there is an unrecoverable error in the scheduler or
	 * scheduler driver. The driver will be aborted BEFORE invoking this
	 * callback.
	 */
	@Override
	public void error(SchedulerDriver driver, String message) {
		System.out.println("Error: " + message);
	}

	/**
	 * Invoked when an executor has exited/terminated. Note that any
	 * tasks running will have TASK_LOST status updates automagically
	 * generated.
	 */
	@Override
	public void executorLost(SchedulerDriver driver, ExecutorID executorId, SlaveID slaveId, int status) {
	}

	/**
	 * Invoked when an executor sends a message. These messages are best
	 * effort; do not expect a framework message to be retransmitted in
	 * any reliable fashion.
	 */
	@Override
	public void frameworkMessage(SchedulerDriver driver, ExecutorID executorId, SlaveID slaveId, byte[] data) {
	}

	/**
	 * Invoked when an offer is no longer valid (e.g., the slave was
	 * lost or another framework used resources in the offer). If for
	 * whatever reason an offer is never rescinded (e.g., dropped
	 * message, failing over framework, etc.), a framwork that attempts
	 * to launch tasks using an invalid offer will receive TASK_LOST
	 * status updats for those tasks (see Scheduler::resourceOffers).
	 */
	@Override
	public void offerRescinded(SchedulerDriver driver, OfferID offerId) {
	}

	/**
	 * Invoked when the scheduler successfully registers with a Mesos
	 * master. A unique ID (generated by the master) used for
	 * distinguishing this framework from others and MasterInfo
	 * with the ip and port of the current master are provided as arguments.
	 */
	@Override
	public void registered(SchedulerDriver driver, FrameworkID frameworkId, MasterInfo masterInfo) {
		System.out.println("Registered! ID = " + frameworkId.getValue());
	}

	/**
	 * Invoked when the scheduler re-registers with a newly elected Mesos master.
	 * This is only called when the scheduler has previously been registered.
	 * MasterInfo containing the updated information about the elected master
	 * is provided as an argument.
	 */
	@Override
	public void reregistered(SchedulerDriver driver, MasterInfo masterInfo) {
	}

	/**
	 * Invoked when resources have been offered to this framework. A
	 * single offer will only contain resources from a single slave.
	 * Resources associated with an offer will not be re-offered to
	 * _this_ framework until either (a) this framework has rejected
	 * those resources (see SchedulerDriver::launchTasks) or (b) those
	 * resources have been rescinded (see Scheduler::offerRescinded).
	 * Note that resources may be concurrently offered to more than one
	 * framework at a time (depending on the allocator being used). In
	 * that case, the first framework to launch tasks using those
	 * resources will be able to use them while the other frameworks
	 * will have those resources rescinded (or if a framework has
	 * already launched tasks with those resources then those tasks will
	 * fail with a TASK_LOST status and a message saying as much).
	 */
	@Override
	public void resourceOffers(SchedulerDriver driver, List<Offer> offers) {
		for (Offer offer : offers) {
			List<TaskInfo> tasks = new ArrayList<TaskInfo>();

			// Should we launch a task?
			if (launchedTasks < totalTasks) {
				// Assign a task ID and name
				TaskID taskId = TaskID.newBuilder().setValue(Integer.toString(launchedTasks++)).build();
				String taskName = "task " + taskId.getValue();
				System.out.println("Launching task " + taskId.getValue());

				// Resources
				Resource cpus = Resource.newBuilder().setName("cpus").setType(Value.Type.SCALAR).setScalar(Value.Scalar.newBuilder().setValue(1)).build(); // Number of cores
				Resource mem = Resource.newBuilder().setName("mem").setType(Value.Type.SCALAR).setScalar(Value.Scalar.newBuilder().setValue(128)).build(); // Memory in MB

				// Command
				CommandInfo cmd = CommandInfo.newBuilder() //
						.setValue("/bin/ls") //
						.build();

				// Executor
				ExecutorInfo execInfo = ExecutorInfo.newBuilder(executor).build();

				// Task's data: Command to execute
				ByteString data = ByteString.copyFromUtf8("/bin/ls -al");

				// Create task
				TaskInfo task = TaskInfo.newBuilder() //
						.setName(taskName)//
						.setTaskId(taskId) //
						.setSlaveId(offer.getSlaveId()) //
						.addResources(cpus) //
						.addResources(mem) //
						.setExecutor(execInfo) //
						.setData(data) //
						.build();

				// Add task to response
				tasks.add(task);
			}

			Filters filters = Filters.newBuilder().setRefuseSeconds(1).build();
			driver.launchTasks(offer.getId(), tasks, filters);
		}
	}

	/**
	 * Invoked when a slave has been determined unreachable (e.g.,
	 * machine failure, network partition). Most frameworks will need to
	 * reschedule any tasks launched on this slave on a new slave.
	 */
	@Override
	public void slaveLost(SchedulerDriver driver, SlaveID slaveId) {
	}

	/**
	 * Invoked when the status of a task has changed (e.g., a slave is
	 * lost and so the task is lost, a task finishes and an executor
	 * sends a status update saying so, etc). Note that returning from
	 * this callback _acknowledges_ receipt of this status update! If
	 * for whatever reason the scheduler aborts during this callback (or
	 * the process exits) another status update will be delivered (note,
	 * however, that this is currently not true if the slave sending the
	 * status update is lost/fails during that time).
	 */
	@Override
	public void statusUpdate(SchedulerDriver driver, TaskStatus status) {
		System.out.println("Status update: task " + status.getTaskId().getValue() + " is in state " + status.getState());

		if ((status.getState() == TaskState.TASK_FINISHED) //
				|| (status.getState() == TaskState.TASK_FAILED) //
				|| (status.getState() == TaskState.TASK_KILLED) //
				|| (status.getState() == TaskState.TASK_LOST) //
				) {
			// TODO: Task finished, clean up

			finishedTasks++;
			System.out.println("Finished tasks: " + finishedTasks);
			if (finishedTasks == totalTasks) {
				driver.stop();
			}
		}
	}
}
